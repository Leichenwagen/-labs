''' Вариант 2. Вычислить сумму знакопеременного ряда |х^(2n+1)|/(2n+1)!, где х-матрица ранга к (к и матрица задаются
 случайным образом), n - номер слагаемого. Сумма считается вычисленной, если точность вычислений будет не меньше t
 знаков после запятой. У алгоритма д.б. линейная сложность. Операция умножения –поэлементная. Знак первого слагаемого +.'''
import numpy as np
from decimal import Decimal, getcontext
def custom_sum(x, t):# Принимает матрицу x и точность t для вычисления суммы знакопеременного ряда.
    znam, sign, n = 1, 1, 1 # Инициализация переменных
    summa, delta = 0, 0
    matrix_power = np.eye(x.shape[0], dtype=float) # Создание единичной матрицы того же размера, что и входная матрица x.
    while True:# Бесконечный цикл для вычисления суммы ряда с учетом точности.
        znam *= (2 * n) * (2 * n + 1)# Вычисление знаменателя для текущего слагаемого.
        summand = Decimal(np.linalg.det(matrix_power)) / Decimal(znam)# Вычисление текущего слагаемого и добавление его к общей сумме.
        summa += sign * summand
        n += 1 # Инкрементация индекса n и изменение знака для следующей итерации.
        sign = -sign
        delta += summa # Обновление переменных для проверки точности.
        matrix_power = np.dot(matrix_power, x)  # Обновление степени матрицы инкрементально.
        # print(n - 1, ':', f'Текущая сумма: {summa}, Слагаемое {summand}, Текущий знаменатель: {znam}') # # Печать значений для отладки.
        if abs(summand) < Decimal('1e-{}'.format(t)):# Проверка точности. Если текущее слагаемое меньше, чем заданная точность, выход из цикла.
            print(f'Количество итераций: {n - 1}')
            break
    return summa # Возвращение вычисленной суммы ряда.
try:
    t = int(input("Введите число t, являющееся точностью (количеством знаков после запятой): "))# Ввод точности t от пользователя.
    while t > 100 or t < 1:# Проверка на допустимость введенной точности.
        t = int(input("Введите число t, большее или равное 1:\n"))
    k = np.random.randint(2, 11)# Генерация случайной размерности матрицы от 2 до 10.
    x = np.random.uniform(-1.0, 1.0, size=(k, k))# Генерация случайной вещественной матрицы размера (k, k).
    Rang = np.linalg.matrix_rank(x)# Вычисление ранга матрицы x.
    getcontext().prec = t + 100# Установка точности для десятичных вычислений.
    np.set_printoptions(linewidth=200)
    print("Сгенерированная матрица:\n", x)# Печать сгенерированной матрицы и ее ранга.
    print("Ранг матрицы:", Rang)
    summa = custom_sum(x, t)# Вычисление суммы ряда и округление до указанной точности.
    rounded_summa = round(summa, t)
    print(f"Сумма ряда с точностью {t} знаков после запятой с округлением: {rounded_summa}")
except ValueError:# Обработка ошибки ввода (если введено не число).
    print("\nВведенный символ не является числом. Перезапустите программу и введите число.")
    rounded_result = Decimal(sum_of_results).quantize(Decimal('0.{}'.format('0' * t)))# Округляем результаты до заданного числа знаков после запятой.
    print(f"Сумма ряда с точностью {t} знаков после запятой: {rounded_result}")
except ValueError:# Если введено не число, то выводим сообщение об ошибке.
    print("\nВведенный символ не является числом. Перезапустите программу и введите число.")
