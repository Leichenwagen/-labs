# Вариант 2. Вычислить сумму знакопеременного ряда |х(2n+1)|/(2n+1)!, где х-матрица ранга к (к и матрица задаются 
# случайным образом), n - номер слагаемого. Сумма считается вычисленной, если точность вычислений будет не меньше t 
# знаков после запятой. У алгоритма д.б. линейная сложность. Операция умножения –поэлементная. Знак первого слагаемого +.
import random
import numpy as np
from decimal import Decimal, getcontext
import math
def custom_sum(x, t):# Функция для вычисления суммы ряда до указанной точности t.
    n = 1
    curr_x = x ** (2 * n + 1)  # Подготовка текущего элемента curr_x, возведенного в определённую степень.
    factorial = math.factorial(2 * n + 1)  # Подготовка факториала для нижней части разложения.
    res = Decimal(0)  # Подготовка результирующего числа, где будет сохранён конечный итог.
    sign = 1  # Начинаем с положительного знака.
    while True:# Входим в бесконечный цикл, который будем прерывать когда достигнем потребованной точности.
        curr_term = Decimal(curr_x) / Decimal(factorial)  # Вычисляем текущее слагаемое.
        res += sign * curr_term  # Добавляем его к результату.
        if abs(curr_term) < Decimal('1e-{}'.format(t)): # Если значение текущего слагаемого меньше указанной точности, останавливаем вычисление.
            break
        n += 1
        sign = -sign  # Чередуем знаки слагаемых ряда.
        factorial *= int(2 * n) * int(2 * n + 1)  # Считаем новый факториал.
        curr_x *= x ** (2 * n + 1)  # Считаем новое значение для числа.
    return res
try:
    t = int(input("Введите число t, являющееся точностью (количеством знаков после запятой): "))
    while t > 100 or t < 1:
        t = int(input("Вы ввели число, неподходящее по условию, введите число t, большее или равное 1:\n"))
    k = random.randint(1, 10)  # Генерируем размерность исходной матрицы.
    x = np.random.uniform(-1.0, 1.0, (k, k))  # если нужны вещественные числа
    np.set_printoptions(linewidth=200)
    print("Сгенерированная матрица:\n", x)
    x_vector = x.ravel()  # Преобразуем матрицу в одномерный массив.
    getcontext().prec = t + 10  # Устанавливаем точность десятичных вычислений.
    result = [custom_sum(val, t) for val in x_vector]  # Вычисляем сумму ряда для каждого элемента массива.
    sum_of_results = sum(result)  # Подсчитываем общую сумму.
    rounded_result = Decimal(sum_of_results).quantize(Decimal('0.{}'.format('0' * t)))# Округляем результаты до заданного числа знаков после запятой.
    print(f"Сумма ряда с точностью {t} знаков после запятой: {rounded_result}")
except ValueError:# Если введено не число, то выводим сообщение об ошибке.
    print("\nВведенный символ не является числом. Перезапустите программу и введите число.")
